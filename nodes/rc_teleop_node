#!/usr/bin/env python2
import rospy
from std_msgs.msg import Empty
from mavros_msgs.msg import RCIn
from geometry_msgs.msg import Twist



class RCState:
    def __init__(self):
        self.rc_channels = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ]

        self.emergency_stop = False
        self.flight_mode = None
        self.land = False

        return



class RCTeleOpNode:
    def __init__(self, transmitter_ranges, normalization_ranges, eps=5):

        # Maintain the current state
        self.rc_prev_state = RCState()

        # Epsilon value used to provide a buffer for switch pwm values
        self.eps = eps

        # The parameterized RC settings
        self.transmitter_ranges = transmitter_ranges
        self.normalization_ranges = normalization_ranges

        # ROS Subscribers
        self.mavros_subscriber = rospy.Subscriber("/mavros/rc/in", RCIn, callback=self.__transmitter_cb)

        # ROS Publishers
        self.pub_cmd_out = rospy.Publisher('cmd_vel', Twist, queue_size=10, latch=False)
        self.pub_manual_takeoff = rospy.Publisher('manual_takeoff', Empty, queue_size=1, latch=False)
        self.pub_emergency = rospy.Publisher('emergency', Empty,  queue_size=1, latch=False)
        self.pub_land = rospy.Publisher('land', Empty,  queue_size=1, latch=False)

        return

    
    def __normalize_to_range(self, value, value_min, value_max, range_min=-1, range_max=1):
        """
        Normalize a value to the range [-1, 1]
        """
        return (range_max - range_min) * (value - value_min) / (value_max - value_min) - range_max


    def __get_current_state(self, channels):
        """
        Extract the current state

        Channel 4 (Switch E):
            965: Manual
            1515: AltHold
            2065: Computer

        Channel 5 (Switch C):
            965: Emergency Stop
            2065: Land
        """
        state = RCState()

        # Process Channels 4 (Switch E)
        if channels[4] <= self.transmitter_ranges['manual_mode'] + self.eps and \
           channels[4] >= self.transmitter_ranges['manual_mode'] - self.eps:
            state.flight_mode = 'manual'
        elif channels[4] <= self.transmitter_ranges['althold_mode'] + self.eps and \
           channels[4] >= self.transmitter_ranges['althold_mode'] - self.eps:
            state.flight_mode = 'althold'
        elif channels[4] <= self.transmitter_ranges['computer_mode'] + self.eps and \
           channels[4] >= self.transmitter_ranges['computer_mode'] - self.eps:
            state.flight_mode = 'computer'
        else:
            state.flight_mode = None

        # Process Channel 5 (Switch C)
        if channels[5] <= self.transmitter_ranges['emergency_stop'] + self.eps and \
           channels[5] >= self.transmitter_ranges['emergency_stop'] - self.eps:
           state.emergency_stop = True
        elif channels[5] <= self.transmitter_ranges['land'] + self.eps and \
           channels[5] >= self.transmitter_ranges['land'] - self.eps:
           state.land = True

        return state


    def __transmitter_cb(self, msg):
        """
        Convert the MAVROS message into a joy message and forward the converted message
        """
        # Extract the current state
        rc_current_state = self.__get_current_state(msg.channels)

        if rc_current_state.flight_mode == 'manual':
            self.pub_manual_takeoff.publish()

        # Process emergency stop
        if not self.rc_prev_state.emergency_stop and rc_current_state.emergency_stop:
            self.pub_emergency.publish()
            return

        # Process land
        if not self.rc_prev_state.land and rc_current_state.land:
            self.pub_land.publish()

        # Manual control mode
        cmd = Twist()

        # Populate the command with normalized values
        cmd.linear.x = self.__normalize_to_range(
            msg.channels[0], 
            self.transmitter_ranges['min_roll'], 
            self.transmitter_ranges['max_roll'], 
            range_min=self.normalization_ranges['roll_range_min'],
            range_max=self.normalization_ranges['roll_range_max']
        )

        cmd.linear.y = -self.__normalize_to_range(
            msg.channels[1], 
            self.transmitter_ranges['min_pitch'], 
            self.transmitter_ranges['max_pitch'], 
            range_min=self.normalization_ranges['pitch_range_min'],
            range_max=self.normalization_ranges['pitch_range_max']
        )

        cmd.linear.z = self.__normalize_to_range(
            msg.channels[2], 
            self.transmitter_ranges['min_thrust'], 
            self.transmitter_ranges['max_thrust'], 
            range_min=self.normalization_ranges['thrust_range_min'],
            range_max=self.normalization_ranges['thrust_range_max']
        )

        cmd.angular.z = self.__normalize_to_range(
            msg.channels[3], 
            self.transmitter_ranges['min_yaw'], 
            self.transmitter_ranges['max_yaw'], 
            range_min=self.normalization_ranges['yaw_range_min'],
            range_max=self.normalization_ranges['yaw_range_max']
        )
        
        # Publish the command
        self.pub_cmd_out.publish(cmd)

        # Copy remaining previous state
        self.rc_prev_state = rc_current_state

        return



def main():
    # Initialize the node
    rospy.init_node('rc_teleop_node', anonymous=True)

    # Instantiate a new forwarder with the set ranges
    teleop_node = RCTeleOpNode(
        {
            'max_thrust': rospy.get_param('~max_thrust'),
            'min_thrust': rospy.get_param('~min_thrust'),
            'max_yaw': rospy.get_param('~max_yaw'),
            'min_yaw': rospy.get_param('~min_yaw'),
            'max_pitch': rospy.get_param('~max_pitch'),
            'min_pitch': rospy.get_param('~min_pitch'),
            'max_roll': rospy.get_param('~max_roll'),
            'min_roll': rospy.get_param('~min_roll'),
            'manual_mode': rospy.get_param('~manual_mode'),
            'althold_mode': rospy.get_param('~althold_mode'),
            'computer_mode': rospy.get_param('~computer_mode'),
            'emergency_stop': rospy.get_param('~emergency_stop'),
            'land': rospy.get_param('~land')
        },
        {
            'roll_range_max': rospy.get_param('~roll_range_max'),
            'roll_range_min': rospy.get_param('~roll_range_min'),
            'pitch_range_max': rospy.get_param('~pitch_range_max'),
            'pitch_range_min': rospy.get_param('~pitch_range_min'),
            'yaw_range_max': rospy.get_param('~yaw_range_max'),
            'yaw_range_min': rospy.get_param('~yaw_range_min'),
            'thrust_range_max': rospy.get_param('~thrust_range_max'),
            'thrust_range_min': rospy.get_param('~thrust_range_min')
        }
    )

    # Run until the node is stopped
    rospy.spin()

    return


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass